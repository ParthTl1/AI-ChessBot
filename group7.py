# -*- coding: utf-8 -*-
"""group7_final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qwZFD6zrfP5FzXe-nx5Ne-6qDPLBJPMr
"""

!pip install chess
from typing import Dict, List, Any
import chess as ch
import sys
import time
import math


SCORE_MATE     = 1000000000
THRESHOLD =  999000000


debug_info: Dict[str, Any] = {}

pVALS = {
    ch.PAWN: 100,
    ch.ROOK: 500,
    ch.KNIGHT: 320,
    ch.BISHOP: 330,
    ch.QUEEN: 900,
    ch.KING: 20000
}

pawnValWhite = [
    0,  0,  0,  0,  0,  0,  0,  0,
    5, 10, 10, -20, -20, 10, 10,  5,
    5, -5, -10,  0,  0, -10, -5,  5,
    0,  0,  0, 45, 35,  0,  0,  0,
    5,  5, 10, 25, 25, 10,  5,  5,
    10, 10, 20, 30, 30, 20, 10, 10,
    50, 50, 50, 50, 50, 50, 50, 50,
    0, 0, 0, 0, 0, 0, 0, 0
]

pawnValBlack =  [0,  0,  0,  0,  0,  0,  0,  0,
50, 50, 50, 50, 50, 50, 50, 50,
10, 10, 20, 30, 30, 20, 10, 10,
 5,  5, 10, 5, 0, 10,  5,  5,
 0,  0,  0, 20, 20,  0,  0,  0,
 5, -5,-10,  0,  0,-10, -5,  5,
 5, 10, 10,-20,-20, 10, 10,  5,
 0,  0,  0,  0,  0,  0,  0,  0]




bishopValWhite = [
    -20, -10, -10, -10, -10, -10, -10, -20,
    -10, 5, 0, 0, 0, 0, 5, -10,
    -10, 10, 10, 10, 10, 10, 10, -10,
    -10, 0, 10, 10, 10, 10, 0, -10,
    -10, 5, 5, 10, 10, 5, 5, -10,
    -10, 0, 5, 10, 10, 5, 0, -10,
    -10, 0, 0, 0, 0, 0, 0, -10,
    -20, -10, -10, -10, -10, -10, -10, -20
]
bishopValBlack = list(reversed(bishopValWhite))

knightVal = [
    -40, -30, -20, -20, -20, -20, -30, -40,
    -30, -10, 0, 5, 5, 0, -10, -30,
    -20, 5, 10, 15, 15, 10, 5, -20,
    -20, 0, 15, 20, 20, 15, 0, -20,
    -20, 5, 15, 20, 20, 15, 5, -20,
    -20, 0, 10, 15, 15, 10, 0, -20,
    -30, -10, 0, 0, 0, 0, -10, -30,
    -40, -30, -20, -20, -20, -20, -30, -40
]

rookValWhite = [
    0, 0, 0, 5, 5, 0, 0, 0,
    -5, 0, 0, 0, 0, 0, 0, -5,
    -5, 0, 0, 0, 0, 0, 0, -5,
    -5, 0, 0, 0, 0, 0, 0, -5,
    -5, 0, 0, 0, 0, 0, 0, -5,
    -5, 0, 0, 0, 0, 0, 0, -5,
    5, 10, 10, 10, 10, 10, 10, 5,
    0, 0, 0, 0, 0, 0, 0, 0
]
rookValBlack = list(reversed(rookValWhite))

queenEval = [
    -20, -10, -10, -5, -5, -10, -10, -20,
    -10, 0, 0, 0, 0, 0, 0, -10,
    -10, 0, 5, 5, 5, 5, 0, -10,
    -5, 0, 5, 5, 5, 5, 0, -5,
    0, 0, 5, 5, 5, 5, 0, -5,
    -10, 5, 5, 5, 5, 5, 0, -10,
    -10, 0, 5, 0, 0, 0, 0, -10,
    -20, -10, -10, -5, -5, -10, -10, -20
]

kingEvalWhite = [
    20, 30, 10, 0, 0, 10, 30, 20,
    20, 20, 0, 0, 0, 0, 20, 20,
    -10, -20, -20, -20, -20, -20, -20, -10,
    20, -30, -30, -40, -40, -30, -30, -20,
    -30, -40, -40, -50, -50, -40, -40, -30,
    -30, -40, -40, -50, -50, -40, -40, -30,
    -30, -40, -40, -50, -50, -40, -40, -30,
    -30, -40, -40, -50, -50, -40, -40, -30
]
kingEvalBlack = list(reversed(kingEvalWhite))

kingEvalEndGameWhite = [
    50, -30, -30, -30, -30, -30, -30, -50,
    -30, -30,  0,  0,  0,  0, -30, -30,
    -30, -10, 20, 30, 30, 20, -10, -30,
    -30, -10, 30, 40, 40, 30, -10, -30,
    -30, -10, 30, 40, 40, 30, -10, -30,
    -30, -10, 20, 30, 30, 20, -10, -30,
    -30, -20, -10,  0,  0, -10, -20, -30,
    -50, -40, -30, -20, -20, -30, -40, -50
]
kingEvalEndGameBlack = list(reversed(kingEvalEndGameWhite))


def evaluate_capture(board: ch.Board, move: ch.Move) -> float:

    if board.is_en_passant(move):
        return pVALS[ch.PAWN]

    _to = board.piece_at(move.to_square)
    _from = board.piece_at(move.from_square)
    if _to is None or _from is None:
        raise Exception(
            f"{move.to_square} and {move.from_square}"
        )

    if(board.turn == ch.WHITE):
        temp = ch.BLACK
    else:
        temp = ch.WHITE
    if len(board.attackers(temp, move.to_square)) >= 1:
        return pVALS[_to.piece_type] - pVALS[_from.piece_type]

    return pVALS[_to.piece_type]


def move_value(board: ch.Board, move: ch.Move, endgame: bool) -> float:

    if move.promotion is not None:
        return -float(math.inf) if board.turn == ch.BLACK else float(math.inf)

    _piece = board.piece_at(move.from_square)
    if _piece:
        from_value = evaluate_piece(_piece, move.from_square, endgame)
        to_value = evaluate_piece(_piece, move.to_square, endgame)
        position_change = to_value - from_value
    else:
        raise Exception(f"{move.from_square}")

    capturedValue = 0.0
    if board.is_capture(move):
        capturedValue = evaluate_capture(board, move)

    current_move_value = capturedValue + position_change
    if board.turn == ch.BLACK:
        current_move_value = -current_move_value

    return current_move_value



def evaluate_piece(piece: ch.Piece, square: ch.Square, end_game: bool) -> int:

    piece_type = piece.piece_type
    mapping = []

    if piece_type == ch.KNIGHT:
        mapping = knightVal
    if piece_type == ch.PAWN:
        mapping = pawnValWhite if piece.color == ch.WHITE else pawnValBlack

    if piece_type == ch.ROOK:
        mapping = rookValWhite if piece.color == ch.WHITE else rookValBlack
    if piece_type == ch.BISHOP:
        mapping = bishopValWhite if piece.color == ch.WHITE else bishopValBlack
    if piece_type == ch.QUEEN:
        mapping = queenEval
    if piece_type == ch.KING:
        if end_game:
            mapping = (
                kingEvalEndGameWhite
                if piece.color == ch.WHITE
                else kingEvalEndGameBlack
            )
        else:
            mapping = kingEvalWhite if piece.color == ch.WHITE else kingEvalBlack

    return mapping[square]


def evaluate_board(board: ch.Board) -> float:

    total = 0
    end_game = is_endgame(board)

    for square in ch.SQUARES:
        piece = board.piece_at(square)
        if not piece:
            continue

        # imp = 1
        # if(piece.piece_type == ch.PAWN):
        #     imp = 1.5

        value = pVALS[piece.piece_type] + evaluate_piece(piece, square, end_game)
        total += value if piece.color == ch.WHITE else -value

    return total


def is_endgame(board: ch.Board) -> bool:

    queens = 0
    minors = 0

    for square in ch.SQUARES:
        piece = board.piece_at(square)
        if piece and piece.piece_type == ch.QUEEN:
            queens += 1
        if piece and (
            piece.piece_type == ch.BISHOP or piece.piece_type == ch.KNIGHT
        ):
            minors += 1

    if queens == 0 or (queens == 2 and minors <= 1):
        return True

    return False

def next_move(board:ch.Board, depth:int = 3, debug=True)->ch.Move:

    debug_info.clear()
    debug_info["nodes"] = 0
    t = time.time()

    move = mm_root(depth, board)

    debug_info["time"] = time.time() - t
    if(debug):
        print(f"info {debug_info}")
    return move


def get_ordered_moves(board: ch.Board) -> List[ch.Move]:

    end_game = is_endgame(board)

    def orderer(move):
        return move_value(board, move, end_game)

    sorted_moves = sorted(board.legal_moves, key=orderer, reverse=(board.turn == ch.WHITE))
    return list(sorted_moves)


def mm_root(depth: int, board: ch.Board) -> ch.Move:
    maximize = (board.turn == ch.WHITE)
    best_move = -float(math.inf)
    if not maximize:
        best_move = float(math.inf)

    moves = get_ordered_moves(board)
    best_result = moves[0]

    for options in moves:
        board.push(options)

        if(board.can_claim_draw()):
            value = 0.00
        else:
            value = minimax(depth - 1, board, -float(math.inf), float(math.inf), not maximize)

        board.pop()

        if(maximize):
            if(value >= best_move):
                best_move = value
                best_result = options
        else:
            if(value <= best_move):
                best_move = value
                best_result = options

    return best_result


def minimax(depth: int, board: ch.Board,alpha: float, beta: float, my_player: bool) -> float:
    debug_info["nodes"] += 1

    if (board.is_checkmate()):

        return -SCORE_MATE if my_player else SCORE_MATE

    elif (board.is_game_over()):
        return 0

    if (depth == 0):
        return evaluate_board(board)

    if (my_player == True):

        options = get_ordered_moves(board)

        best_move = -float(math.inf)

        for option in options:
            board.push(option)
            current_choice = minimax(depth - 1, board, alpha, beta, not my_player)

            if current_choice > THRESHOLD:
                current_choice -= 1
            elif current_choice < -THRESHOLD:
                current_choice += 1
            best_move = max(best_move, current_choice)
            board.pop()
            alpha = max(alpha, best_move)
            if beta <= alpha:
                return best_move
        return best_move

    else:
        best_move = float(math.inf)

        moves = get_ordered_moves(board)

        for move in moves:
            board.push(move)
            current_choice = minimax(depth - 1, board, alpha, beta, not my_player)

            if (current_choice > THRESHOLD):
                current_choice -= 1
            elif (current_choice < -THRESHOLD):
                current_choice += 1

            best_move = min(best_move,current_choice)
            board.pop()
            beta = min(beta, best_move)

            if(alpha >= beta):
                return best_move


        return best_move

class group1:
    def __init__(self, color):
        self.color = color

    def makemove(self, board):
        retmove=""
        legal_moves = board.legal_moves
        print("The list of legal moves are: ")
        print(legal_moves)
        chosen_move = next_move(board)
        retmove = board.uci(chosen_move)

        return retmove